# 1장 - 오브젝트와 의존관계

## Intro

### 스프링의 핵심 철학 

객체지향 프로그래밍이 제공하는 가치를 누리자. 기본으로 돌아가자. 오브젝트에 대한 관심.

### 오브젝트에 대한 관심?

* 오브젝트의 라이프 사이클
    * 오브젝트의 생성, 소멸
    * 타 오브젝트와 관계맺기, 사용
* 오브젝트의 설계
    * OOD(Object oriented design) 원칙, 기초
    * 디자인 패턴 - 다양한 목적에 부합되게 재활용 가능한 설계
    * 리팩토링 - 지속적인 구조 개선
    * 단위 테스트 - 오브젝트의 동작이 기대한 대로 되는지 검증
    
### 결국 스프링이 제공하는 것

* 오브젝트를 어떻게 설계, 구현, 사용, 개선에 대한 명쾌한 기준 제시
* 검증된 베스트 프렉티스 제공
    * 객체지향 기술
    * 설계, 구현에 관한 실용적 전략

## 1.1. 초난감 DAO

```
== DAO ==

DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 역할을 하는 오브젝트
```

가장 기본적인 JDBC 코드 부터 시작한다. 지금 코드는 그냥 인터넷에 뿌려진 여느 예제와 같고, 실제 서비스에 적용하기에는 문제가 많다.

앞으로 이 예제가 위의 오브젝트에 대한 관심과 스프링의 기능의 도움을 받아 강력한 어플리케이션으로 탈바꿈하는지 꼼꼼히 살펴보자.

## 1.2. DAO의 분리

* 우리가 늘 염두에 두어야 하는것 1법칙
    * **소프트웨어는 끊임없이 변한다**
* 교훈은? **현명한 개발자는 미래의 변화에 대비한다.**
* 객체지향 기술은 변화에 효과적으로 대처가능함
* 어떻게 변화에 대응할 것인가?
    * 변화의 폭을 최소화한다. -> **분리와 확장**을 고려한 설계가 필요
* **분리와 확장**
    * 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해 일어난다.
        * 이런일은 없다 - "DB를 오라클에서 MySql로 바꾸면서, 웹 화면의 레이아웃을 다중 프레임 구조에서 단을 프레임에 Ajax를 적용한 구조로 바꾸고...."
        * 주로 이렇다 - "DB 접속암호가 A에서 B로 변경됩니다. 바꾸세요."
    * 우리의 문제 변화는 1건인데, 우리가 작업할 것은 n~무한대
    * 그래서..
        * 한 가지 관심이 한 곳에 집중되게 해야 함. 
        * 즉, 최대한 한 작업이 일어나면 한 곳만 변경하게 미리 준비
        * 공식용어 - **Separation of Concerns** (관심사의 분리)
            * 관심이 같은 것끼리 하나의 객체 안으로 혹은 친한 객체끼리 묶기
            * 관심이 다른 것은 따로 떨어뜨리기

결론 - 관심사 기준으로 객체의 나누기와 합치기를 잘 해보자!

### 1.2.2 커넥션 만들기의 추출

* 중복코드를 단일 class 안에서 하나의 메소드로 추출한다.

### 1.2.3. DB 커넥션 만들기의 독립

* 여러 확장 방법이 존재
* **상속을 통한 확장**
* 'DB 커넥션 연결' 이라는 관심을 분리
    * 어떻게? 상속을 이용 서브클래스에 관심사를 둠
    * 관심사가 이렇게 나뉘었다.
        * UserDao - 어떻게 데이터를 가져올 것인가?(SQL작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)
        * NUserDao/DUserDao - DB 연결은 어떻게 할 것인가?
    * Template Method Pattern(템플릿 메소드 패턴)
        * 슈퍼 클래스
            * 로직의 기본흐름, 
            * 기능 일부를 추상 메소드나 오버라이딩 가능 메소드를 제공
        * 서브 클래스
            * 위의 추상 메소드나 오버라이딩 가능 메소드를 필요에 맞게 구현해서 사용
    * Factory Method Pattern(펙토리 메소드 패턴)
        * getConnection()
        * 슈퍼 클래스 - Connection 타입 오브젝트가 만들어질 것을 메소드 정의만 함
        * 서브 클래스 - 구체적인 오브젝트 생성 방법을 결정
    * 단점
        * 상속 자체가 가지고 있는 문제
            * 이미 NUserDao 가 다른것을 상속중이라면 대책이 없음(Java는 오직 단일 상속)
            * fragile base class(깨지기 쉬운 기반 클래스 문제) - 자세한 내용은 검색!
                * UserDao 의 변화가 클수록, NUserDao 가 의도치 않은 사이드 이펙트가 날수 있음
        
        
    디자인 패턴에서 가장 중요한 것은? 
        - 목적과 의도
        - etc
            - 적용할 상황
            - 해결해야 할 문제
            - 솔루션의 구조와 각 요소의 역할


## 1.3. DAO의 확장

### 1.3.1. 클래스의 분리

* 좀 더 다른 방식으로 분리해보자!
    * 서로 독립적인 class 로 존재하게
    * composition(합성) 방식
    
* 하지만 합성으로 특성 클래스에 종속된다면?
    * SimpleConnectionMaker 의 makeNewConnection() 을 이름 변경만 있어도 UserDao가 변경이 일어남.
    * 다른종류의 SimpleConnectionMaker 와 바꾸려면? UserDao도 변경이 일어남(아래 요부분)
    ```java
    public UserDao() {
        this.simpleConnectionMaker = new SimpleConnectionMaker();
    }
    ```
