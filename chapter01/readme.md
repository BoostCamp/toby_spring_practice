# 1장 - 오브젝트와 의존관계

## Intro

### 스프링의 핵심 철학 

객체지향 프로그래밍이 제공하는 가치를 누리자. 기본으로 돌아가자. 오브젝트에 대한 관심.

### 오브젝트에 대한 관심?

* 오브젝트의 라이프 사이클
    * 오브젝트의 생성, 소멸
    * 타 오브젝트와 관계맺기, 사용
* 오브젝트의 설계
    * OOD(Object oriented design) 원칙, 기초
    * 디자인 패턴 - 다양한 목적에 부합되게 재활용 가능한 설계
    * 리팩토링 - 지속적인 구조 개선
    * 단위 테스트 - 오브젝트의 동작이 기대한 대로 되는지 검증
    
### 결국 스프링이 제공하는 것

* 오브젝트를 어떻게 설계, 구현, 사용, 개선에 대한 명쾌한 기준 제시
* 검증된 베스트 프렉티스 제공
    * 객체지향 기술
    * 설계, 구현에 관한 실용적 전략

## 1.1. 초난감 DAO

```
== DAO ==

DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 역할을 하는 오브젝트
```

가장 기본적인 JDBC 코드 부터 시작한다. 지금 코드는 그냥 인터넷에 뿌려진 여느 예제와 같고, 실제 서비스에 적용하기에는 문제가 많다.

앞으로 이 예제가 위의 오브젝트에 대한 관심과 스프링의 기능의 도움을 받아 강력한 어플리케이션으로 탈바꿈하는지 꼼꼼히 살펴보자.

## 1.2. DAO의 분리

* 우리가 늘 염두에 두어야 하는것 1법칙
    * **소프트웨어는 끊임없이 변한다**
* 교훈은? **현명한 개발자는 미래의 변화에 대비한다.**
* 객체지향 기술은 변화에 효과적으로 대처가능함
* 어떻게 변화에 대응할 것인가?
    * 변화의 폭을 최소화한다. -> **분리와 확장**을 고려한 설계가 필요
* **분리와 확장**
    * 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해 일어난다.
        * 이런일은 없다 - "DB를 오라클에서 MySql로 바꾸면서, 웹 화면의 레이아웃을 다중 프레임 구조에서 단을 프레임에 Ajax를 적용한 구조로 바꾸고...."
        * 주로 이렇다 - "DB 접속암호가 A에서 B로 변경됩니다. 바꾸세요."
    * 우리의 문제 변화는 1건인데, 우리가 작업할 것은 n~무한대
    * 그래서..
        * 한 가지 관심이 한 곳에 집중되게 해야 함. 
        * 즉, 최대한 한 작업이 일어나면 한 곳만 변경하게 미리 준비
        * 공식용어 - **Separation of Concerns** (관심사의 분리)
            * 관심이 같은 것끼리 하나의 객체 안으로 혹은 친한 객체끼리 묶기
            * 관심이 다른 것은 따로 떨어뜨리기

결론 - 관심사 기준으로 객체의 나누기와 합치기를 잘 해보자!

### 1.2.2 커넥션 만들기의 추출

* 중복코드를 단일 class 안에서 하나의 메소드로 추출한다.

### 1.2.3. DB 커넥션 만들기의 독립

* 여러 확장 방법이 존재
* **상속을 통한 확장**
* 'DB 커넥션 연결' 이라는 관심을 분리
    * 어떻게? 상속을 이용 서브클래스에 관심사를 둠
    * 관심사가 이렇게 나뉘었다.
        * UserDao - 어떻게 데이터를 가져올 것인가?(SQL작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)
        * NUserDao/DUserDao - DB 연결은 어떻게 할 것인가?
    * Template Method Pattern(템플릿 메소드 패턴)
        * 슈퍼 클래스
            * 로직의 기본흐름, 
            * 기능 일부를 추상 메소드나 오버라이딩 가능 메소드를 제공
        * 서브 클래스
            * 위의 추상 메소드나 오버라이딩 가능 메소드를 필요에 맞게 구현해서 사용
    * Factory Method Pattern(펙토리 메소드 패턴)
        * getConnection()
        * 슈퍼 클래스 - Connection 타입 오브젝트가 만들어질 것을 메소드 정의만 함
        * 서브 클래스 - 구체적인 오브젝트 생성 방법을 결정
    * 단점
        * 상속 자체가 가지고 있는 문제
            * 이미 NUserDao 가 다른것을 상속중이라면 대책이 없음(Java는 오직 단일 상속)
            * fragile base class(깨지기 쉬운 기반 클래스 문제) - 자세한 내용은 검색!
                * UserDao 의 변화가 클수록, NUserDao 가 의도치 않은 사이드 이펙트가 날수 있음
        
        
    디자인 패턴에서 가장 중요한 것은? 
        - 목적과 의도
        - etc
            - 적용할 상황
            - 해결해야 할 문제
            - 솔루션의 구조와 각 요소의 역할


## 1.3. DAO의 확장

### 1.3.1. 클래스의 분리

* 좀 더 다른 방식으로 분리해보자!
    * 서로 독립적인 class 로 존재하게
    * composition(합성) 방식
    
* 하지만 합성으로 특성 클래스에 종속된다면?
    * SimpleConnectionMaker 의 makeNewConnection() 을 이름 변경만 있어도 UserDao가 변경이 일어남.
    * 다른종류의 SimpleConnectionMaker 와 바꾸려면? UserDao도 변경이 일어남(아래 요부분)
    ```java
    public UserDao() {
        this.simpleConnectionMaker = new SimpleConnectionMaker();
    }
    ```

### 1.3.2. 인터페이스의 도입

* 추상화란?
    * 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업
    * 그 추상화를 위한 도구 - 인터페이스
    
* 인터페이스 
    * 어떤 일을 하겠다는 기능만 정의
    * 어떻게 하겠다는 자신을 구현한 클래스에 맞겨둠
    * 자신을 구현한 클래스에 대한 구체적 정보를 모두 감춤
    * 인터페이스를 사용하는 코드 쪽에서는 인터페이스로 추상화한 통로(기능)만 이해하면 됨
    * 위의 특성이 모여서 -> 구현 클래스간 느슨한 연결고리 역할
    
* 그러나 아직도 UserDao에 '어떤 ConnectionMaker 구현 클래스를 사용할지 결정'하는 코드가 남아있어 완전히 분리가 안된 상황
    ```java
    public UserDao() {
        this.connectionMaker = new NConnectionMaker();
    }
    ```

### 1.3.3. 관계설정 책임의 분리

* 위의 '어떤 ConnectionMaker 구현 클래스를 사용할지 결정' 코드 문제를 해결할 기막힌 방법이 없을까?
    * 사실 '어떤 ConnectionMaker 구현 클래스를 사용할지 결정'도 하나의 관심사다.
    * 이 관심사는 어디다 두어야 하나?
    * 아래에 해답이 있다

* 용어
    * 2개의 오브젝트가 있는데 A 오브젝트가 B 오브젝트의 기능을 사용한다 가정
    * B 오브젝트가 A 오브젝트에게 서비스를 제공하는 셈
    * B 오브젝트 - 서비스 오브젝트
    * A 오브젝트 - 클라이언트 오브젝트
    
* UserDao 와 ConnectionMaker 구현 클래스의 관계를 결정해주는 코드를 놓기에 적절한 곳은?
    * 정답은 UserDao의 클라이언트 오브젝트! 즉 제 3의 오브젝트(외부에서 만들게)
    * 예제에서는 UserDaoTest 라는 Test 코드에서 하도록 함.(즉 UserDaoTest가 클라이언트 오브젝트)    
    
### 1.3.4. 원칙과 패턴
* 객체지향 설계 원칙 - 일반적인 객체지향에서 적용 가능한 설계 기준
* Open-Closed Principle(OCP, 개방 폐쇄 법칙)
    * 클래스나 모듈은
        * 확장에는 열려 있어야 하고
        * 변경에는 닫혀 있어야 한다
    
    * Case : UserDao
        * DB 연결 기능을 확장하는데 열려있다.
        * UserDao 자신의 핵심 기능을 구현한 코드는 DB 연결기능의 변화에 영향없이 유지할수 있다.
        * 인터페이스
            * 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방됨
            * 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 이렁나지 않도록 굳게 폐쇄됨
        
* High coherence and low coupling(높은 응집도와 낮은 결합도)
    * 높은 응집도 
        * 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중됨. 
        * 결과적으로 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
    * 낮은 결합도
        * 결합도 - 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도
        * 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 좋다
        * 느슨한 연결 - 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적 형태로 제공, 나머지는 서로 독립적이고 알 필요 없게 만든다.

    * Case : UserDao
        * UserDao 는 ConnectionMaker 의 관계는 인터페이스를 통해 매우 느슨하게 연결되어 있음.
        * UserDao 입장에서는 구체적인 ConnectionMaker 구현 클래스의 구현 방법이나 전략, 뒤에서 사용하는 오브젝트에 대해서 알 필요 없음
        
* Strategy Pattern(전략 패턴)
    * 자신의 기능 Context(맥락)에서 필요에 따라 
        * 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리
        * 구체적인 알고리즘을 인터페이스 구현을 해서 필요에 따라 바꿔서 사용할 수 있게 하는
        * 디자인 패턴
* 스프링의 역할 - 위의 객체지향적인 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크